<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D魔方演示</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',
            secondary: '#10B981',
            accent: '#8B5CF6',
            dark: '#1F2937',
            light: '#F3F4F6'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .cube-shadow {
        box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
      }
      .sticker-hover {
        transition: transform 0.2s ease;
      }
      .sticker-hover:hover {
        transform: scale(1.05);
      }
      .control-btn {
        @apply bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded-lg transition-all duration-300 shadow-md hover:shadow-lg transform hover:-translate-y-1;
      }
      .mobile-control {
        @apply bg-secondary hover:bg-secondary/90 text-white font-medium py-3 px-4 rounded-full shadow-lg transition-all duration-300;
      }
      .perspective {
        perspective: 1000px;
      }
      .preserve-3d {
        transform-style: preserve-3d;
      }
      .rotate-x {
        transform: rotateX(var(--rotate-x, 0deg));
      }
      .rotate-y {
        transform: rotateY(var(--rotate-y, 0deg));
      }
      .backface-hidden {
        backface-visibility: hidden;
      }
    }
  </style>
</head>
<body class="bg-gradient-to-br from-light to-gray-200 min-h-screen font-sans text-dark">
  <header class="container mx-auto px-4 py-6">
    <h1 class="text-[clamp(1.75rem,5vw,2.5rem)] font-bold text-center text-dark mb-2">3D魔方演示</h1>
    <p class="text-center text-gray-600 max-w-2xl mx-auto">交互式魔方模拟器，支持桌面和移动设备操作。旋转、学习并掌握魔方的每一种变化！</p>
  </header>

  <main class="container mx-auto px-4 py-8">
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
      <!-- 魔方展示区 -->
      <div class="lg:col-span-2 flex justify-center items-center">
        <div class="perspective">
          <div id="cube-container" class="preserve-3d transition-transform duration-500 ease-in-out">
            <!-- 魔方将在这里渲染 -->
          </div>
        </div>
      </div>

      <!-- 控制面板 -->
      <div class="bg-white rounded-2xl p-6 shadow-xl">
        <h2 class="text-xl font-bold mb-4 text-primary">魔方控制</h2>
        
        <div class="grid grid-cols-2 gap-3 mb-6">
          <button onclick="rotate('U', 'clockwise')" class="control-btn">
            <i class="fa-solid fa-rotate-right mr-2"></i>上层右转
          </button>
          <button onclick="rotate('U', 'counter')" class="control-btn">
            <i class="fa-solid fa-rotate-left mr-2"></i>上层左转
          </button>
          
          <button onclick="rotate('D', 'clockwise')" class="control-btn">
            <i class="fa-solid fa-rotate-right mr-2"></i>下层右转
          </button>
          <button onclick="rotate('D', 'counter')" class="control-btn">
            <i class="fa-solid fa-rotate-left mr-2"></i>下层左转
          </button>
          
          <button onclick="rotate('F', 'clockwise')" class="control-btn">
            <i class="fa-solid fa-rotate-right mr-2"></i>前面右转
          </button>
          <button onclick="rotate('F', 'counter')" class="control-btn">
            <i class="fa-solid fa-rotate-left mr-2"></i>前面左转
          </button>
          
          <button onclick="rotate('B', 'clockwise')" class="control-btn">
            <i class="fa-solid fa-rotate-right mr-2"></i>后面右转
          </button>
          <button onclick="rotate('B', 'counter')" class="control-btn">
            <i class="fa-solid fa-rotate-left mr-2"></i>后面左转
          </button>
          
          <button onclick="rotate('L', 'clockwise')" class="control-btn">
            <i class="fa-solid fa-rotate-right mr-2"></i>左面右转
          </button>
          <button onclick="rotate('L', 'counter')" class="control-btn">
            <i class="fa-solid fa-rotate-left mr-2"></i>左面左转
          </button>
          
          <button onclick="rotate('R', 'clockwise')" class="control-btn">
            <i class="fa-solid fa-rotate-right mr-2"></i>右面右转
          </button>
          <button onclick="rotate('R', 'counter')" class="control-btn">
            <i class="fa-solid fa-rotate-left mr-2"></i>右面左转
          </button>
        </div>
        
        <div class="flex justify-between mb-6">
          <button onclick="shuffleCube()" class="control-btn bg-accent hover:bg-accent/90">
            <i class="fa-solid fa-random mr-2"></i>随机打乱
          </button>
          <button onclick="resetCube()" class="control-btn bg-gray-600 hover:bg-gray-700">
            <i class="fa-solid fa-refresh mr-2"></i>重置魔方
          </button>
        </div>
        
        <div class="bg-gray-50 rounded-xl p-4">
          <h3 class="font-bold text-gray-700 mb-2">移动设备操作</h3>
          <p class="text-gray-600 text-sm">在手机上，可以通过拖动来旋转整个魔方，点击任意面来执行旋转操作。</p>
        </div>
      </div>
    </div>
    
    <!-- 移动设备控制面板 -->
    <div class="lg:hidden fixed bottom-4 left-0 right-0 flex justify-center z-50">
      <div class="bg-white rounded-full shadow-2xl p-4 flex space-x-4">
        <button onclick="rotate('U', 'clockwise')" class="mobile-control">U</button>
        <button onclick="rotate('F', 'clockwise')" class="mobile-control">F</button>
        <button onclick="rotate('R', 'clockwise')" class="mobile-control">R</button>
        <button onclick="rotate('B', 'clockwise')" class="mobile-control">B</button>
        <button onclick="rotate('L', 'clockwise')" class="mobile-control">L</button>
        <button onclick="rotate('D', 'clockwise')" class="mobile-control">D</button>
      </div>
    </div>
  </main>

  <footer class="container mx-auto px-4 py-6 mt-12 text-center text-gray-500">
    <p>© 2025 3D魔方演示 | 一个交互式魔方学习工具</p>
  </footer>

  <script>
    // 颜色常量
    const COLORS = {
      'U': '#FFFFFF',  // 白
      'D': '#FFFF00',  // 黄
      'L': '#FFA500',  // 橙
      'R': '#FF0000',  // 红
      'F': '#00FF00',  // 绿
      'B': '#0000FF'   // 蓝
    };

    // 魔方状态
    let cube = {
      U: Array(3).fill().map(() => Array(3).fill('U')),
      D: Array(3).fill().map(() => Array(3).fill('D')),
      L: Array(3).fill().map(() => Array(3).fill('L')),
      R: Array(3).fill().map(() => Array(3).fill('R')),
      F: Array(3).fill().map(() => Array(3).fill('F')),
      B: Array(3).fill().map(() => Array(3).fill('B'))
    };

    // 邻接关系配置
    const adjacentEdges = {
      F: {
        top:    { face: 'U', edge: 'bottom', reverse: false },
        right:  { face: 'R', edge: 'left',    reverse: false },
        bottom: { face: 'D', edge: 'top',    reverse: false },
        left:   { face: 'L', edge: 'right',   reverse: false }
      },
      B: {
        top:    { face: 'U', edge: 'top',     reverse: false },
        right:  { face: 'L', edge: 'left',    reverse: false },
        bottom: { face: 'D', edge: 'bottom', reverse: false },
        left:   { face: 'R', edge: 'right',   reverse: false }
      },
      U: {
        top:    { face: 'B', edge: 'bottom', reverse: true },
        right:  { face: 'R', edge: 'top',    reverse: false },
        bottom: { face: 'F', edge: 'top',    reverse: false },
        left:   { face: 'L', edge: 'top',    reverse: false }
      },
      D: {
        top:    { face: 'F', edge: 'bottom', reverse: false },
        right:  { face: 'R', edge: 'bottom', reverse: false },
        bottom: { face: 'B', edge: 'top',    reverse: true },
        left:   { face: 'L', edge: 'bottom', reverse: false }
      },
      L: {
        top:    { face: 'U', edge: 'left',   reverse: false },
        right:  { face: 'F', edge: 'left',    reverse: false },
        bottom: { face: 'D', edge: 'left',   reverse: false },
        left:   { face: 'B', edge: 'right',   reverse: true }
      },
      R: {
        top:    { face: 'U', edge: 'right',  reverse: false },
        right:  { face: 'B', edge: 'left',    reverse: true },
        bottom: { face: 'D', edge: 'right',  reverse: false },
        left:   { face: 'F', edge: 'right',   reverse: false }
      }
    };

    // 魔方旋转状态
    let rotationState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      rotateX: 0,
      rotateY: 0,
      currentX: 0,
      currentY: 0
    };

    // 初始化渲染
    function renderCube() {
      const cubeContainer = document.getElementById('cube-container');
      cubeContainer.innerHTML = '';
      
      // 设置魔方整体样式
      cubeContainer.style.width = '180px';
      cubeContainer.style.height = '180px';
      cubeContainer.style.transform = `rotateX(${rotationState.rotateX}deg) rotateY(${rotationState.rotateY}deg)`;
      
      // 渲染六个面
      const facePositions = {
        F: { translateZ: '90px', rotateY: '0deg' },
        B: { translateZ: '-90px', rotateY: '180deg' },
        U: { translateY: '-90px', rotateX: '90deg' },
        D: { translateY: '90px', rotateX: '-90deg' },
        L: { translateX: '-90px', rotateY: '-90deg' },
        R: { translateX: '90px', rotateY: '90deg' }
      };
      
      Object.entries(cube).forEach(([faceKey, faceData]) => {
        const faceElement = document.createElement('div');
        faceElement.className = 'absolute w-full h-full preserve-3d';
        faceElement.style.transform = `translateZ(${facePositions[faceKey].translateZ || '0px'}) 
                                      rotateX(${facePositions[faceKey].rotateX || '0deg'}) 
                                      rotateY(${facePositions[faceKey].rotateY || '0deg'})`;
        faceElement.dataset.face = faceKey;
        
        // 渲染每个面上的小方块
        faceData.forEach((row, rowIndex) => {
          row.forEach((color, colIndex) => {
            const sticker = document.createElement('div');
            sticker.className = 'absolute w-[58px] h-[58px] border border-gray-300 rounded-md sticker-hover';
            sticker.style.backgroundColor = COLORS[color];
            sticker.style.transform = `translateX(${(colIndex - 1) * 60}px) translateY(${(rowIndex - 1) * 60}px)`;
            sticker.dataset.row = rowIndex;
            sticker.dataset.col = colIndex;
            sticker.dataset.face = faceKey;
            
            // 添加点击旋转事件
            sticker.addEventListener('click', () => handleStickerClick(faceKey, rowIndex, colIndex));
            
            faceElement.appendChild(sticker);
          });
        });
        
        // 添加面点击事件
        faceElement.addEventListener('click', (e) => {
          if (e.target === faceElement) {
            rotate(faceKey, 'clockwise');
          }
        });
        
        cubeContainer.appendChild(faceElement);
      });
      
      // 添加拖拽旋转事件
      setupDragEvents();
    }

    // 处理贴纸点击，确定旋转方向
    function handleStickerClick(faceKey, rowIndex, colIndex) {
      // 根据点击的位置确定旋转方向
      // 这里简化处理，只考虑顺时针和逆时针
      const centerRow = 1;
      const centerCol = 1;
      
      // 计算相对中心的位置
      const rowDiff = rowIndex - centerRow;
      const colDiff = colIndex - centerCol;
      
      // 根据点击位置确定旋转方向
      let direction = 'clockwise';
      
      // 对于U, D, F, B面，根据点击位置决定方向
      if (['U', 'D', 'F', 'B'].includes(faceKey)) {
        // 如果点击在右侧或下方，使用逆时针
        if (colDiff > 0 || rowDiff > 0) {
          direction = 'counter';
        }
      } 
      // 对于L, R面，方向判断相反
      else if (['L', 'R'].includes(faceKey)) {
        if (colDiff > 0 || rowDiff > 0) {
          direction = 'clockwise';
        } else {
          direction = 'counter';
        }
      }
      
      rotate(faceKey, direction);
    }

    // 设置拖拽事件
    function setupDragEvents() {
      const cubeContainer = document.getElementById('cube-container');
      
      // 鼠标事件
      cubeContainer.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', endDrag);
      
      // 触摸事件
      cubeContainer.addEventListener('touchstart', startDrag, { passive: false });
      cubeContainer.addEventListener('touchmove', drag, { passive: false });
      cubeContainer.addEventListener('touchend', endDrag);
    }

    // 开始拖拽
    function startDrag(e) {
      e.preventDefault();
      rotationState.isDragging = true;
      
      if (e.type === 'mousedown') {
        rotationState.startX = e.clientX;
        rotationState.startY = e.clientY;
      } else {
        rotationState.startX = e.touches[0].clientX;
        rotationState.startY = e.touches[0].clientY;
      }
      
      rotationState.currentX = rotationState.rotateX;
      rotationState.currentY = rotationState.rotateY;
    }

    // 拖拽中
    function drag(e) {
      if (!rotationState.isDragging) return;
      e.preventDefault();
      
      let clientX, clientY;
      
      if (e.type === 'mousemove') {
        clientX = e.clientX;
        clientY = e.clientY;
      } else {
        clientX = e.touches[0].clientX;
        clientY = e.touches[0].clientY;
      }
      
      const diffX = clientX - rotationState.startX;
      const diffY = clientY - rotationState.startY;
      
      rotationState.rotateY = rotationState.currentY + diffX * 0.5;
      rotationState.rotateX = rotationState.currentX - diffY * 0.5;
      
      // 更新魔方旋转
      const cubeContainer = document.getElementById('cube-container');
      cubeContainer.style.transform = `rotateX(${rotationState.rotateX}deg) rotateY(${rotationState.rotateY}deg)`;
    }

    // 结束拖拽
    function endDrag() {
      rotationState.isDragging = false;
    }

    // 旋转面
    function rotateFace(face, direction) {
      const newFace = [];
      for (let i = 0; i < 3; i++) {
        newFace[i] = direction === 'clockwise' 
          ? [face[2][i], face[1][i], face[0][i]]
          : [face[0][2-i], face[1][2-i], face[2][2-i]];
      }
      return newFace;
    }

    // 旋转边
    function rotateEdges(faceKey, direction) {
      const edges = ['top', 'right', 'bottom', 'left'];
      const temp = edges.map(edge => {
        const config = adjacentEdges[faceKey][edge];
        const data = getEdgeData(cube[config.face], config.edge);
        return config.reverse ? data.reverse() : data;
      });

      // 顺时针旋转：将最后一个元素移到前面
      // 逆时针旋转：将第一个元素移到后面
      direction === 'clockwise' ? temp.unshift(temp.pop()) : temp.push(temp.shift());

      edges.forEach((edge, i) => {
        const config = adjacentEdges[faceKey][edge];
        let data = temp[i];
        if (config.reverse) data = data.reverse();
        setEdgeData(cube[config.face], config.edge, data);
      });
    }

    function getEdgeData(face, edge) {
      if (edge === 'top') return [...face[0]];
      if (edge === 'bottom') return [...face[2]];
      if (edge === 'left') return face.map(row => row[0]);
      if (edge === 'right') return face.map(row => row[2]);
    }

    function setEdgeData(face, edge, data) {
      if (edge === 'top') face[0] = data;
      else if (edge === 'bottom') face[2] = data;
      else if (edge === 'left') data.forEach((v, i) => face[i][0] = v);
      else if (edge === 'right') data.forEach((v, i) => face[i][2] = v);
    }

    // 综合旋转操作，添加动画效果
    function rotate(faceKey, direction) {
      // 禁用交互
      document.getElementById('cube-container').style.pointerEvents = 'none';
      
      // 应用旋转
      cube[faceKey] = rotateFace(cube[faceKey], direction);
      rotateEdges(faceKey, direction);
      
      // 渲染魔方，但暂时不应用旋转
      const originalRotateX = rotationState.rotateX;
      const originalRotateY = rotationState.rotateY;
      rotationState.rotateX = 0;
      rotationState.rotateY = 0;
      renderCube();
      
      // 获取面元素
      const faceElement = document.querySelector(`[data-face="${faceKey}"]`);
      
      // 添加旋转动画
      faceElement.style.transition = 'transform 0.5s ease';
      
      // 根据面和方向设置旋转角度
      let rotationAngle = direction === 'clockwise' ? '90deg' : '-90deg';
      let rotationAxis = 'rotateY';
      
      if (faceKey === 'U' || faceKey === 'D') {
        rotationAxis = 'rotateX';
      } else if (faceKey === 'L' || faceKey === 'R') {
        rotationAxis = 'rotateZ';
      }
      
      faceElement.style.transform = `${faceElement.style.transform} ${rotationAxis}(${rotationAngle})`;
      
      // 动画结束后恢复并重新渲染
      setTimeout(() => {
        faceElement.style.transition = 'none';
        faceElement.style.transform = faceElement.style.transform.replace(`${rotationAxis}(${rotationAngle})`, '');
        
        // 恢复原始旋转
        rotationState.rotateX = originalRotateX;
        rotationState.rotateY = originalRotateY;
        renderCube();
        
        // 启用交互
        document.getElementById('cube-container').style.pointerEvents = 'auto';
      }, 500);
    }

    // 随机打乱魔方
    function shuffleCube() {
      const moves = ['U', 'D', 'F', 'B', 'L', 'R'];
      const directions = ['clockwise', 'counter'];
      const shuffleLength = 20;
      
      let shuffleMoves = [];
      for (let i = 0; i < shuffleLength; i++) {
        const move = moves[Math.floor(Math.random() * moves.length)];
        const direction = directions[Math.floor(Math.random() * directions.length)];
        shuffleMoves.push({ move, direction });
      }
      
      // 按顺序执行打乱步骤
      executeMoves(shuffleMoves, 0);
    }

    // 执行一系列旋转
    function executeMoves(moves, index) {
      if (index >= moves.length) return;
      
      const { move, direction } = moves[index];
      rotate(move, direction);
      
      setTimeout(() => {
        executeMoves(moves, index + 1);
      }, 550); // 等待旋转动画完成
    }

    // 重置魔方
    function resetCube() {
      // 重置魔方状态
      cube = {
        U: Array(3).fill().map(() => Array(3).fill('U')),
        D: Array(3).fill().map(() => Array(3).fill('D')),
        L: Array(3).fill().map(() => Array(3).fill('L')),
        R: Array(3).fill().map(() => Array(3).fill('R')),
        F: Array(3).fill().map(() => Array(3).fill('F')),
        B: Array(3).fill().map(() => Array(3).fill('B'))
      };
      
      // 添加重置动画
      const cubeContainer = document.getElementById('cube-container');
      cubeContainer.style.transition = 'transform 0.8s ease-out';
      cubeContainer.style.transform = 'rotateX(0deg) rotateY(0deg)';
      
      // 重置旋转状态
      rotationState.rotateX = 0;
      rotationState.rotateY = 0;
      
      // 延迟渲染以显示动画
      setTimeout(() => {
        cubeContainer.style.transition = 'none';
        renderCube();
      }, 800);
    }

    // 初始渲染
    renderCube();
  </script>
</body>
</html>
    